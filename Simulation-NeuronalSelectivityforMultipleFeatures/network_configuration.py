######### Wenqing Wei ################
# network configuration
# the simulation runs on NEST 2.20
############################################################
# In this file, two functions are written to run   #########
# the simulation. Both of them are spiking neural  #########
# networks. In our network configuration, a number #########
# dLGN neurons project to single FFI and V1 cells. #########
# Therefore, there are two methods to implement    #########
# the input to cortical cells: 1. use poisson      #########
# generators to generate spikes of single dLGN     #########
# cells; 2. use poisson generators to generate     #########
# spikes of the compound thalamic input to FFI     #########
# and V1 cells. In the function 'single_dLGN_spk_  #########
# network', the spikes of single dLGN cells are    #########
# generated, while in the function 'compound_spk_  #########
# network', the spikes of the compound inputs,     #########
# i.e. the summed dLGN responses, are generated    #########
# by poisson generators. Note that the two         #########
# implementations only have statistical differences#########
# due to random process but no qualitative variation.#######
############################################################

import numpy as np
import random
import nest
from importlib import reload
import parameters; reload(parameters); from parameters import *

nest.set_verbosity('M_FATAL')
nest.ResetKernel()
nest.SetKernelStatus({'overwrite_files': True,
					  'total_num_virtual_procs': n_vp})
nest.SetKernelStatus({'print_time': True})


# generate and save data in fig3_Compound_thalamic_input.py 
locs = np.load('input_data/input_locs.npy', allow_pickle=True)[0]
V1_locs = locs['V1_locs']
dLGN_locs = locs['dLGN_locs']
FFI_locs = locs['FFI_locs']

# load connection files
conn_e = np.load('input_data/conn_e.npy')
conn_i = np.load('input_data/conn_i.npy')
conn_FV = np.load('input_data/conn_FV.npy')


def nearest_idx(nps, single_V1, nn):
    ''' get the nn nn nearest indices of dLGN neurons to a single V1 neuron.
    Return an array with nn integers.
    Parameters:
    nps : array, shape (n, 2), positions.
    single_V1 : array, shape (2,) or (1, 2), one position.
    nn : int, the number of nearest points to single_V1.'''
    c = nps - single_V1.reshape((1,2))
    distance = np.sqrt(np.einsum('ij, ij->i', c, c))
    nearest_id = distance.argsort()[:nn]
    return nearest_id


def mvalue(Fre_spa, sigv):
    ''' calculate the m value shown in the related paper.
    Return a float.
    Parameters: 
    Fre_spa : float, the spatial frequency of the stimulus grating.
    sigv : array or tuple with 2 non negative real numbers. The 2 numbers are the standard deviations of the Gaussians of DoG model of the dLGN's receptive field. The first one should be the std of the center Gaussian and latter one be the std of the surround Gaussian.'''
    sf = 2 * np.pi * Fre_spa
    return np.exp(-sf ** 2 * sigv[0]**2/2.) - np.exp(-sf**2 * sigv[1] **2/2.)

def optimal_sf(sigv):
    ''' calculate the optimal spatial frequency which returns the maximum value of m.
    Return a float.
    Parameters:
    sigv : array or tuple with 2 non negative real numbers. The 2 numbers are the standard deviations of the Gaussians of DoG model of the dLGN's receptive field. The first one should be the std of the center Gaussian and latter one be the std of the surround Gaussian.'''
    sf = 2 * np.sqrt(np.log(sigv[1]/sigv[0])/(sigv[1]**2 - sigv[0]**2))
    Fre_spa = sf/(2 * np.pi)
    return Fre_spa

def m_max(sigv):
    ''' calculate the maximum value of m with the given sigmas of the DoG model.
    Return a float.
    Parameters:
    sigv : array or tuple with 2 non negative real numbers. The 2 numbers are the standard deviations of the Gaussians of DoG model of the dLGN's receptive field. The first one should be the std of the center Gaussian and latter one be the std of the surround Gaussian.'''
    Fre_spa = optimal_sf(sigv)
    m = mvalue(Fre_spa, sigv)
    return m





def single_dLGN_spk_network(V1_locs, LGN_locs, FFI_locs, ext_rate, theta, A=100., Fre_spa=0.08, sigc=1., sigs=5., J_LF=2.0, J_FFI_V1=-1.6, n_LF=8, n_LV=100, n_FFI_V1=320, cm=1.0, a=2):
    ''' Create the network and run simulation. Here the response spikes of single dLGN sensors are generated by sinusoidal poisson generators.
    Parameters:
    V1_locs : positions of receptive field center of V1 sensors.
    LGN_locs : positions of receptive field center of dLGN sensors.
    FFI_locs : positions of receptive field center of FFI sensors.
    ext_rate : the rate of external input.
    theta : the radian of the orientation of the stimulus grating.
    A : the response of dLGN sensors in response to mean luminance.
    Fre_spa : spatial frequency of the stimulus grating.
    sigc : standard deviation of the center Gaussian of DoG model.
    sigs : standard deviation of the surround Gaussian of DoG model.
    J_LF : the synaptic weight of dLGN --> FFI.
    J_FFI_V1 : the synaptic weight of FFI --> V1.
    n_LF : the convergent number of dLGN --> FFI.
    n_LV : the convergent number of dLGN --> V1.
    n_FFI_V1 : the convergent number of FFI --> V1.
    cm : the contrast of the stimulus grating.
    a : simulation seed.
    '''
    
    # Set Kernel
    nest.ResetKernel()
    nest.SetKernelStatus({'overwrite_files': True,
					      'total_num_virtual_procs': n_vp})
    nest.SetKernelStatus({'print_time': True})
  
    # set seed ====================================================================
    msd = 1234 * a * 100 + 1
    n_vp_g = nest.GetKernelStatus('total_num_virtual_procs')
    msdrange2 = range(msd + n_vp_g + 1, msd + 2 * n_vp_g + 1)
        
    nest.SetKernelStatus({'rng_seeds':msdrange2,'grng_seed':msd + n_vp_g})
    #==============================================================================
    # create V1 nodes 
    V1_nodes = nest.Create('iaf_psc_delta', N, params = {'tau_m': tau_m,
                                                         't_ref': t_ref,
                                                         'V_th': V_th,
                                                         'V_reset': V_reset,
                                                         'E_L': E_L})
    
    V1_E, V1_I = V1_nodes[:Ne], V1_nodes[Ne:]
    
    # create external input and connect to V1 neurons
    external_input = nest.Create('poisson_generator', 1, {'rate': ext_rate})
    syn_ext = {'model': 'static_synapse', 'delay': delay, 'weight': J_ext}
    nest.Connect(external_input, V1_nodes, syn_spec = syn_ext)

    
    #################################################################################
    ############################################
    ###### recurrent connections ###############
    ############################################
    list_exc_pre = list(np.asarray(V1_nodes)[conn_e.ravel()])
    list_exc_post = list(np.repeat([V1_nodes], ind_E))
    
    syn_dict_exc = {'model': 'static_synapse', 'delay': delay, 'weight': J_E}
    nest.Connect(list_exc_pre, list_exc_post, 'one_to_one', syn_spec = syn_dict_exc)
    
    list_inh_pre = list(np.asarray(V1_nodes)[conn_i.ravel()])
    list_inh_post = list(np.repeat([V1_nodes], ind_I))    
        
    syn_dict_inh = {'model': 'static_synapse', 'delay': delay, 'weight': J_I}
    nest.Connect(list_inh_pre, list_inh_post, 'one_to_one', syn_spec = syn_dict_inh)    
    
    #################################################################################
    
    
    ##### Create LGN sensors and set status ##
    sigv = np.array([sigc, sigs])
    sf = (2 * np.pi) * Fre_spa
    k = sf * np.array([np.sin(theta), -np.cos(theta)]).reshape((2, 1))
    
    mmax = m_max(sigv)
    m_on = mvalue(Fre_spa, sigv)
    m_off = -1 * m_on
    
    alpha = np.concatenate(np.dot(LGN_locs, k))
    phase_shift = np.pi/2 - alpha
    phases = phase_shift * 180./np.pi
    phases = phases.tolist()
    
    lgn_sensors = nest.Create('sinusoidal_poisson_generator', int(len(LGN_locs)),
                            params = {'frequency': Fre_tem, 'rate': mmax * A})
    
    nest.SetStatus(lgn_sensors, 'phase', phases)
    sn = int(len(LGN_locs)/2)
    nest.SetStatus(lgn_sensors[:sn], 'amplitude', A * m_on * cm)
    nest.SetStatus(lgn_sensors[sn:], 'amplitude', A * m_off * cm)
    
    # Create parrot neurons and connect LGN sensors to parrot neurons
    parrot_lgn = nest.Create('parrot_neuron', len(LGN_locs))
    syn_parrot = {'model': 'static_synapse', 'weight': 1.0, 'delay': delay}
    nest.Connect(lgn_sensors, parrot_lgn, 'one_to_one', syn_spec = syn_parrot)
    
    #################################################################################
    
    # Create FFI neurons and connect LGN neuron to them
    
    FFI_nodes = nest.Create('iaf_psc_delta', N_FFI, params = {'tau_m': tau_m,
                                                              't_ref': t_ref,
                                                              'V_th': V_th,
                                                              'V_reset': V_reset,
                                                              'E_L': E_L})
    
    # parrot LGN --> FFI
    lgn_FFI_list, FFI_list = [], []
    for i in range(len(FFI_locs)):
        ids = nearest_idx(LGN_locs, FFI_locs[i], int(n_LF))
        lgn_FFI_list += list(np.asarray(parrot_lgn)[ids])
        FFI_list += [FFI_nodes[i]] * int(n_LF)
    
    syn_lgn_FFI = {'model': 'static_synapse', 'delay': delay, 'weight': J_LF}
    nest.Connect(lgn_FFI_list, FFI_list, 'one_to_one', syn_spec = syn_lgn_FFI)
    
    # LGN --> V1 nodes
    
    lgn_V1_list, V1_list = [], []
    for ii in range(N):
        idx = nearest_idx(LGN_locs, V1_locs[ii], int(n_LV))
        
        lgn_V1_idx = idx 
        lgn_V1_list += list(np.asarray(parrot_lgn)[lgn_V1_idx])
        V1_list += [V1_nodes[ii]] * int(n_LV)

    syn_lgn_V1 = {'model': 'static_synapse', 'delay': delay, 'weight': J_LV}
    nest.Connect(lgn_V1_list, V1_list, 'one_to_one', syn_spec = syn_lgn_V1)
    
       
    # Connect FFI neurons to V1 neurons
    
    list_FFI = list(np.asarray(FFI_nodes)[conn_FV.ravel()])
    list_V1 = list(np.repeat([V1_nodes], n_FFI_V1))
    
    syn_FFI_V1 = {'model': 'static_synapse', 'delay': delay, 'weight': J_FFI_V1}
    nest.Connect(list_FFI, list_V1, 'one_to_one', syn_spec = syn_FFI_V1)
    
    ###############################################################################
    spikedetector = nest.Create('spike_detector', 1, {'start': t_drop})
    nest.Connect(V1_nodes, spikedetector)
    
    
    sd_input = nest.Create('spike_detector', 1, {'start': t_drop})
    nest.Connect(parrot_lgn, sd_input)
    nest.Connect(FFI_nodes, sd_input)
    
    
    nest.Simulate(t_drop + T)
    dSD = nest.GetStatus(spikedetector, keys = 'events')[0]
    dSD_inp = nest.GetStatus(sd_input, keys = 'events')[0]
    
    evs = dSD['senders']
    r = len(evs) * 1000./(N * T)
    print (r)
    return r, dSD, dSD_inp



def get_V1_neuron_rates(folder, V1_locs, LGN_locs, FFI_locs, ext_rate, A=100., Fre_spa=0.08, sigc=1., sigs=5., J_LF=2.0, J_FFI_V1=-1.6, n_LF=8, n_LV=100, n_FFI_V1=320, cm=1.0, a=2, save_spk=True):
    ''' Run the network for all the orientations of the stimulus grating in the range [0°, 180°) with step 15°.'''
    V1_rates = np.empty((N, 12))
    
    deg_range = np.arange(0., 180., 15)
    theta = deg_range * np.pi/180.
    print ('seed=%i'%(a))
    
    for i in range(len(deg_range)):
        print ('\nrunning--%i\n'%(i+1))
        r, dSD, dSD_inp = single_dLGN_spk_network(V1_locs, LGN_locs, FFI_locs, ext_rate, theta[i], A=A, Fre_spa=Fre_spa, sigc=sigc, sigs=sigs, J_LF=J_LF, J_FFI_V1=J_FFI_V1, n_LF=n_LF, n_LV=n_LV, n_FFI_V1=n_FFI_V1, cm=cm, a=a)
        print ('\n a: %i; angle: %i; mean rate: %.2f'%(a, deg_range[i], r))
        
        evs = dSD['senders']
        ts = dSD['times']
        for idx in range(N):
            spikes = len(evs[evs == idx + 1])
            rate = spikes * 1000./T
            V1_rates[idx, i] = rate
        
        if save_spk==True:
            
            np.save(folder + '/V1_ts_evs_deg_%i.npy'%(deg_range[i]), np.array([ts, evs]).T)
            evs_inp, ts_inp = dSD_inp['senders'], dSD_inp['times']
            np.save(folder + '/input_ts_evs_deg_%i.npy'%(deg_range[i]), np.array([ts_inp, evs_inp]).T)
            
    np.save(folder + '/V1_rates.npy', V1_rates)
    return V1_rates




#=========================================================================#
#========== the second simulation network ================================#
#=========================================================================#


def compound_spk_network(amps, phases, FFI_amps, FFI_phases, ext_rate, A=100., J_LF=2.0, J_FFI_V1=-1.6, n_LF=8, n_LV=100, n_FFI_V1=320, cm=1.0, a=2):

    ''' Create the network and run simulation. Here sinusoidal poisson generators are used to create spikes of the compound thalamic signals that project to cortical cells.
    Parameters:
    V1_locs : positions of receptive field center of V1 sensors.
    LGN_locs : positions of receptive field center of dLGN sensors.
    FFI_locs : positions of receptive field center of FFI sensors.
    ext_rate : the rate of external input.
    theta : the radian of the orientation of the stimulus grating.
    A : the response of dLGN sensors in response to mean luminance.
    Fre_spa : spatial frequency of the stimulus grating.
    sigc : standard deviation of the center Gaussian of DoG model.
    sigs : standard deviation of the surround Gaussian of DoG model.
    J_LF : the synaptic weight of dLGN --> FFI.
    J_FFI_V1 : the synaptic weight of FFI --> V1.
    n_LF : the convergent number of dLGN --> FFI.
    n_LV : the convergent number of dLGN --> V1.
    n_FFI_V1 : the convergent number of FFI --> V1.
    cm : the contrast of the stimulus grating.
    a : simulation seed.
    '''
    
    # Set Kernel
    nest.ResetKernel()
    nest.SetKernelStatus({'overwrite_files': True,
					      'total_num_virtual_procs': n_vp})
    nest.SetKernelStatus({'print_time': True})
  
    # set seed ====================================================================
    msd = 1234 * a * 100 + 1
    n_vp_g = nest.GetKernelStatus('total_num_virtual_procs')
    msdrange2 = range(msd + n_vp_g + 1, msd + 2 * n_vp_g + 1)
        
    nest.SetKernelStatus({'rng_seeds':msdrange2,'grng_seed':msd + n_vp_g})
    #==============================================================================
    # create V1 nodes 
    V1_nodes = nest.Create('iaf_psc_delta', N, params = {'tau_m': tau_m,
                                                        't_ref': t_ref,
                                                        'V_th': V_th,
                                                        'V_reset': V_reset,
                                                        'E_L': E_L})
    
    V1_E, V1_I = V1_nodes[:Ne], V1_nodes[Ne:]
    
    # create external input and connect to V1 neurons
    external_input = nest.Create('poisson_generator', 1, {'rate': ext_rate})
    syn_ext = {'model': 'static_synapse', 'delay': delay, 'weight': J_ext}
    nest.Connect(external_input, V1_nodes, syn_spec = syn_ext)
    
    #################################################################################
    ###### recurrent connections ###############
    ############################################
    list_exc_pre = list(np.asarray(V1_nodes)[conn_e.ravel()])
    list_exc_post = list(np.repeat([V1_nodes], int(ind_E)))
    
    syn_dict_exc = {'model': 'static_synapse', 'delay': delay, 'weight': J_E}
    nest.Connect(list_exc_pre, list_exc_post, 'one_to_one', syn_spec = syn_dict_exc)
    
    list_inh_pre = list(np.asarray(V1_nodes)[conn_i.ravel()])
    list_inh_post = list(np.repeat([V1_nodes], int(ind_I)))    
        
    syn_dict_inh = {'model': 'static_synapse', 'delay': delay, 'weight': J_I}
    nest.Connect(list_inh_pre, list_inh_post, 'one_to_one', syn_spec = syn_dict_inh)    
    
    #################################################################################
    ##### Create dLGN sensors -> V1 nodes and set status ########
    #############################################################
    
    lgn_sensors = nest.Create('sinusoidal_poisson_generator', N, 
                              params = {'frequency':Fre_tem, 'rate': mmax*A*n_LV})
    phase_input = (np.pi/2 - phases)*180./np.pi
    nest.SetStatus(lgn_sensors, 'amplitude', (cm * A*amps).tolist())
    nest.SetStatus(lgn_sensors, 'phase', phase_input.tolist())
    
    syn_lgn = {'model': 'static_synapse', 'delay': delay, 'weight': J_LV}
    nest.Connect(lgn_sensors, V1_nodes, 'one_to_one', syn_spec = syn_lgn)
    
    ######################################################################
    ##### Create LGN neurons -> FFI nodes and set status #########
    
    lgn_FFI = nest.Create('sinusoidal_poisson_generator', N_FFI,
                         params = {'frequency': Fre_tem, 'rate': mmax*A*n_LF})
    
    FFI_phase_input = (np.pi/2 - FFI_phases)*180./np.pi
    nest.SetStatus(lgn_FFI, 'amplitude', (cm * A*FFI_amps).tolist())
    nest.SetStatus(lgn_FFI, 'phase', FFI_phase_input.tolist())
    
    FFI_nodes = nest.Create('iaf_psc_delta', N_FFI, params = {'tau_m': tau_m,
                                                             't_ref': t_ref,
                                                             'V_th': V_th,
                                                             'V_reset': V_reset,
                                                             'E_L': E_L})
    syn_FFI = {'model': 'static_synapse', 'delay': delay, 'weight': J_LF}
    nest.Connect(lgn_FFI, FFI_nodes, 'one_to_one', syn_spec = syn_FFI)
    
    # Connect FFI to V1
    list_FFI = list(np.asarray(FFI_nodes)[conn_FV.ravel()])
    list_V1 = list(np.repeat([V1_nodes], n_FFI_V1))
    syn_FFI_V1 = {'model': 'static_synapse', 'delay': delay, 'weight': J_FFI_V1}
    nest.Connect(list_FFI, list_V1, 'one_to_one', syn_spec = syn_FFI_V1)
    #############################################################################
    
    spikedetector = nest.Create('spike_detector', 1, {'start': t_drop})
    nest.Connect(V1_nodes, spikedetector)
    
    sd_FFI = nest.Create('spike_detector', 1, {'start': t_drop})
    nest.Connect(FFI_nodes, sd_FFI)
    
    nest.Simulate(t_drop + T)
    dSD = nest.GetStatus(spikedetector, keys = 'events')[0]
    evs = dSD['senders']
    r = len(evs) * 1000./(N * T)
    
    dSD_FFI = nest.GetStatus(sd_FFI, keys = 'events')[0]
    print (r)
    return dSD, dSD_FFI



def get_compound_V1_rates(all_amps, all_phases, all_FFI_amps, all_FFI_phases, ext_rate, A=100., J_LF=2.0, J_FFI_V1=-1.6, n_LF=8, n_LV=100, n_FFI_V1=320, cm=1.0, a=2, folder=None, save_spk=False):
    
    V1_rates = np.empty((N, all_amps.shape[1]))
    FFI_rates = np.empty((N_FFI, all_FFI_amps.shape[1]))
    
    for i in range(12):
        dSD, dSD_FFI = compound_spk_network(all_amps[:,i], all_phases[:,i], all_FFI_amps[:,i], all_FFI_phases[:,i], ext_rate=ext_rate, A=A, J_LF=J_LF, J_FFI_V1=J_FFI_V1, n_LF=n_LF, n_LV=n_LV, n_FFI_V1=n_FFI_V1, cm=cm, a=a)
        
        ts, evs = dSD['times'], dSD['senders']
        for idx in range(N):
            spikes = len(evs[evs==idx+1])
            rate = spikes*1000./T
            V1_rates[idx, i] = rate
            
        if save_spk==True:
            np.save(folder + '/V1_ts_evs_deg_%i.npy'%(deg_range[i]), np.array([ts, evs]).T)    
            

    return V1_rates




















